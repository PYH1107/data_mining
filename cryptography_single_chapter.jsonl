{"chapter": 1, "title": "Single Chapter Title", "content": "Understanding Cryptography – A Textbook for\nStudents and Practitioners\nby Christof Paar and Jan Pelzl\nwww.crypto-textbook.com\nChapter 11 – Hash Functions\nver. October 29, 2009\nThese slides were prepared by Stefan Heyse and Christof Paar and Jan Pelzl\nSome legal stuff (sorry): Terms of Use\n• The slides can used free of charge. All copyrights for the slides remain with\nChristof Paar and Jan Pelzl.\n• The title of the accompanying book “Understanding Cryptography” by\nSpringer and the author’s names must remain on each slide.\n• If the slides are modified, appropriate credits to the book authors and the\nbook title must remain within the slides.\n• It is not permitted to reproduce parts or all of the slides in printed form\nwhatsoever without written consent by the authors.\nChapter 11 of Understanding Cryptographyby Christof Paar and Jan Pelzl\n2/22\nContent of this Chapter\n•\nWhy we need hash functions\n•\nHow does it work\n•\nSecurity properties\n•\nAlgorithms\n•\nExample: The Secure Hash Algorithm SHA-1\nChapter 11 of Understanding Cryptographyby Christof Paar and Jan Pelzl\n3/22\nContent of this Chapter\n•\nWhy we need hash functions\n•\nHow does it work\n•\nSecurity properties\n•\nAlgorithms\n•\nExample: The Secure Hash Algorithm SHA-1\nChapter 11 of Understanding Cryptographyby Christof Paar and Jan Pelzl\n4/22\nMotivation\nProblem:\nNaive signing of long messages generates a signature of same length.\n• Three Problems\n• Computational overhead\n• Message overhead\n• Security limitations\n• For more info see Section 11.1 in “Understanding Cryptography”.\nSolution:\nInstead of signing the whole message, sign only a digest (=hash)\nAlso secure, but much faster\nNeeded:\nHash Functions\nChapter 11 of Understanding Cryptographyby Christof Paar and Jan Pelzl\n5/22\n(cid:1)\nDigital Signature with a Hash Function\nx\nx\ni\nNotes:\nz = h( x || z ) • x has fixed length\ni i i-1\n• z, y have fixed length\n• z, x do not have equal length in general\nz\n• h(x) does not require a key.\n• h(x) is public.\nsig z)\nk\npr\ny = sig (z)\nk\npr\nChapter 11 of Understanding Cryptographyby Christof Paar and Jan Pelzl\n6/22\n(cid:1)\nBasic Protocol for Digital Signatures with a Hash Function:\nAlice Bob\nK\npub\nz = h(x)\ns = sig (z)\nK\npr\n(x, s)\nz' = h(x)\nver (s,z')=true/false\nK\npub\nChapter 11 of Understanding Cryptographyby Christof Paar and Jan Pelzl\n7/22\n(cid:1)\nPrincipal input–output behavior of hash functions\nChapter 11 ofUnderstanding CryptographybyChristof Paar andJan Pelzl\n8/22\nContent of this Chapter\n•\nWhy we need hash functions\n•\nHow does it work\n•\nSecurity properties\n•\nAlgorithms\n•\nExample: The Secure Hash Algorithm SHA-1\nChapter 11 of Understanding Cryptographyby Christof Paar and Jan Pelzl\n9/22\n(cid:1)\nThe three security properties of hash functions\nChapter 11 ofUnderstanding CryptographybyChristof Paar andJan Pelzl\n10/22\n(cid:1)\nHash Funktionen: Security Properties\n• Preimage resistance: For a given output z, it is impossible to find any\ninput x such that h(x) = z, i.e., h(x) is one-way.\n• Second preimage resistance: Given x , and thus h(x ), it is computa-\n1 1\ntionally infeasible to find any x such that h(x ) = h(x ).\n2 1 2\n• Collision resistance: It is computationally infeasible to find any pairs\n≠\nx x such that h(x ) = h(x ).\n1 2 1 2\nChapter 11 of Understanding Cryptographyby Christof Paar and Jan Pelzl\n11/22\n(cid:1)\nHash Funktionen: Security\nIt turns out that collison resistance causes most problems\n• How hard is it to find a collision with a probability of 0.5 ?\n• Related Problem: How many people are needed such that two\nof them have the same birthday with a probability of 0.5 ?\n• No! Not 365/2=183. 23 are enough ! This is called the\nbirthday paradoxon (Search takes ≈√ 2n steps) .\n• For more info see Chapter 11.2.3 in Understanding\nCryptography.\n• To deal with this paradox, hash functions need a output size of\nat least 160 bits.\nChapter 11 of Understanding Cryptographyby Christof Paar and Jan Pelzl\n12/22\nContent of this Chapter\n•\nWhy we need hash functions\n•\nHow does it work\n•\nSecurity properties\n•\nAlgorithms\n•\nExample: The Secure Hash Algorithm SHA-1\nChapter 11 of Understanding Cryptographyby Christof Paar and Jan Pelzl\n13/22\n(cid:1)\nHash Funktionen: Algorithms\nHash Algorithms\nbased on\nSpecial Algorithms,\nblock ciphers\ne.g. MD5 - family\n• MD5 - family\n• SHA-1: output - 160 Bit; input - 512 bit chunks of message x;\noperations - bitwise AND, OR, XOR, complement und cyclic shifts.\n• RIPE-MD 160: output - 160 Bit; input - 512 bit chunks of message x;\noperations – like in SHA-1, but two in parallel and combinations of them\nafter each round.\nChapter 11 of Understanding Cryptographyby Christof Paar and Jan Pelzl\n14/22\nContent of this Chapter\n•\nWhy we need hash functions\n•\nHow does it work\n•\nSecurity properties\n•\nAlgorithms\n•\nExample: The Secure Hash Algorithm SHA-1\nChapter 11 of Understanding Cryptographyby Christof Paar and Jan Pelzl\n15/22\n(cid:1)\nSHA-1\n•\nPart of the MD-4 family.\n•\nBased on a Merkle-Dåmgard construction.\n•\n160-bit output from a message of maximum length\n264 bit.\n•\nWidely used ( even tough some weaknesses are\nknown)\nChapter 11 of Understanding Cryptographyby Christof Paar and Jan Pelzl\n16/22\n(cid:1)\nSHA-1 High Level Diagramm\n• Compression Function consists of 80 rounds which are divided\ninto four stages of 20 rounds each\nChapter 11 of Understanding Cryptographyby Christof Paar and Jan Pelzl\n17/22\n(cid:1)\nSHA-1: Padding\n• Message x has to be padded to fit a size of a multiple of 512 bit.\n• k ≡ 512 − 64 − 1 − l = 448 − (l + 1) mod 512.\nChapter 11 of Understanding Cryptographyby Christof Paar and Jan Pelzl\n18/22\n(cid:1)\nSHA-1: Hash Computation\n• Each message block x is processed in four stages with 20 rounds each\ni\nSHA-1 uses:\n• A message schedule which computes a 32-bit word W0,W1,...,W79 for each\nof the 80 rounds\n• Five working registers of size of 32 bits A,B,C,D,E\n• A hash value H consisting of five 32-bit words H(0), H(1), H(2) , H(3), H(4)\ni i i i i i\n• In the beginning, the hash value holds the initial value H , which is replaced by\n0\na new hash value after the processing of each single message block.\n• The final hash value H is equal to the output h(x) of SHA-1.\nn\nChapter 11 of Understanding Cryptographyby Christof Paar and Jan Pelzl\n19/22\n(cid:1)\nSHA-1: All four stages\nChapter 11 of Understanding Cryptographyby Christof Paar and Jan Pelzl\n20/22\n(cid:1)\nSHA-1: Internals of a Round\nStage t Round j Constant K Function f\nt t\n1 00…19 K=5A827999 f(B,C,D)=(B∧C)∨(¯ B∧D)\n2 20…39 K=6ED9EBA1 f(B,C,D)=B⊕C⊕D\n3 40…59 K=8F1BBCDC f(B,C,D)=(B⊕C)∨(B⊕D)∨(C⊕D)\n4 60…79 K=CA62C1D6 f(B,C,D)=B⊕C⊕D\nChapter 11 of Understanding Cryptographyby Christof Paar and Jan Pelzl\n21/22\n(cid:1)\nLessons Learned: Hash-Funktionen\n• Hash functions are keyless. The two most important applications of hash\nfunctions are their use in digital signatures and in message authentication\ncodes such as HMAC.\n• The three security requirements for hash functions are one-wayness,\nsecond preimage resistance and collision resistance.\n• Hash functions should have at least 160-bit output length in order to\nwithstand collision attacks; 256 bit or more is desirable for long-term\nsecurity.\n• MD5, which was widely used, is insecure. Serious security weaknesses\nhave been found in SHA-1, and the hash function should be phased out.\nThe SHA-2 algorithms all appear to be secure.\n• The ongoing SHA-3 competition will result in new standardized hash\nfunctions in a few years.\nChapter 11 of Understanding Cryptographyby Christof Paar and Jan Pelzl\n22/22", "exercises": []}
